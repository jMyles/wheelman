// Generated by CoffeeScript 1.4.0
(function() {
  var flatten, wheelman;

  window.wheelman = {};

  wheelman = window.wheelman;

  wheelman.scrollOrders = 0;

  wheelman.scrollZones = [];

  wheelman.slowScrollTo = function(position, speed) {
    var distance, scrollTop, timing;
    scrollTop = $(window).scrollTop();
    distance = Math.abs(position - scrollTop);
    timing = speed ? speed : wheelman.atMost(3000, (distance * 1.5) + 500);
    wheelman.scrollOrders += 1;
    if (wheelman.DEBUG) {
      $('#monitor').html(wheelman.scrollOrders + ': Scrolling from ' + scrollTop + ' to ' + position + "taking " + timing);
    }
    return $('html,body').animate({
      scrollTop: position
    }, timing);
  };

  wheelman.listZones = function() {
    var zone, _i, _len, _ref, _results;
    _ref = wheelman.scrollZones;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      zone = _ref[_i];
      _results.push(console.log(zone.element[0].id + " - " + zone.start + " - " + zone.property));
    }
    return _results;
  };

  wheelman.atMost = function(lim, num) {
    if (num > lim) {
      return lim;
    } else {
      return num;
    }
  };

  wheelman.atLeast = function(lim, num) {
    if (num < lim) {
      return lim;
    } else {
      return num;
    }
  };

  flatten = function(lim, flat, num) {
    if (num < lim) {
      return flat;
    } else {
      return num;
    }
  };

  wheelman.Zone = (function() {

    function Zone(start, end, element) {
      this.start = start;
      this.end = end;
      this.element = element;
      this.features = [];
      wheelman.scrollZones.push(this);
    }

    Zone.prototype.hide = function() {
      return $(this.element.selector + " *").css('visibility', 'hidden');
    };

    Zone.prototype.show = function() {
      return $(this.element.selector + " *").css('visibility', 'visible');
    };

    Zone.prototype.addFeature = function(start, duration, high, low, property, direction, subelement) {
      var element, featureFunc, zoneStart;
      if (direction == null) {
        direction = "in";
      }
      if (subelement) {
        element = $(subelement.selector, this.element.selector);
      } else {
        element = this.element;
      }
      zoneStart = this.start;
      start = zoneStart + start;
      featureFunc = function(position) {
        var differential, distance, value;
        if (position < start) {
          if (direction === "in") {
            value = flatten(low + .01, low, low);
          } else {
            value = high;
          }
        } else {
          distance = position - start;
          differential = distance / duration;
          if (direction === "in") {
            if (high < 0) {
              value = 0 - wheelman.atMost(Math.abs(high), differential);
            } else {
              value = wheelman.atMost(high, differential);
            }
          } else {
            if (low < 0) {
              value = 0 - flatten(Math.abs(low) + .01, Math.abs(low), Math.abs(high) - differential);
            } else {
              value = flatten(low + .01, low, high - differential);
            }
          }
        }
        return element.css(property, value.toFixed(2));
      };
      return this.features.push(featureFunc);
    };

    Zone.prototype.addFade = function(start, duration, direction, subelement) {
      if (start == null) {
        start = this.start;
      }
      if (duration == null) {
        duration = this.end;
      }
      if (direction == null) {
        direction = "in";
      }
      return this.addFeature(start, duration, 1, 0, 'opacity', direction, subelement);
    };

    Zone.prototype.addState = function(start, before, after, property, subelement) {
      var element, stateFunc, zoneStart;
      if (subelement) {
        element = $(subelement.selector, this.element.selector);
      } else {
        element = this.element;
      }
      zoneStart = this.start;
      start = zoneStart + start;
      stateFunc = function(position) {
        if (position > start) {
          return element.css(property, after);
        } else {
          return element.css(property, before);
        }
      };
      return this.features.push(stateFunc);
    };

    Zone.prototype.addFreeze = function(freezePoint) {
      var absTop, buffer, scrolls;
      buffer = 1000;
      scrolls = buffer - freezePoint;
      absTop = buffer + this.start;
      this.addState(scrolls, "absolute", "fixed", 'position');
      return this.addState(scrolls, absTop, freezePoint, 'top');
    };

    return Zone;

  })();

  wheelman.scrollEm = function(position) {
    var feature, zone, _i, _len, _ref, _results;
    _ref = wheelman.scrollZones;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      zone = _ref[_i];
      if (position >= zone.start && position < zone.end) {
        zone.show();
        _results.push((function() {
          var _j, _len1, _ref1, _results1;
          _ref1 = zone.features;
          _results1 = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            feature = _ref1[_j];
            _results1.push(feature(position));
          }
          return _results1;
        })());
      } else {
        _results.push(zone.hide());
      }
    }
    return _results;
  };

  $(function() {
    wheelman.throttledScroll = _.throttle(wheelman.slowScrollTo, 1000, {
      trailing: false
    });
    wheelman.nextZone = function() {
      var landing, scrolltop, _i, _len, _ref;
      scrolltop = $(window).scrollTop();
      _ref = wheelman.landings;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        landing = _ref[_i];
        if (scrolltop < landing && Math.abs(scrolltop - landing) > 100) {
          return wheelman.throttledScroll(landing);
        }
      }
    };
    wheelman.previousZone = function() {
      var landing, scrolltop, _i, _len, _ref, _step;
      scrolltop = $(window).scrollTop();
      _ref = wheelman.landings;
      for (_i = 0, _len = _ref.length, _step = -1; _i < _len; _i += _step) {
        landing = _ref[_i];
        if (scrolltop > landing && Math.abs(scrolltop - landing) > 100) {
          return wheelman.throttledScroll(landing);
        }
      }
    };
    return $("div").swipe({
      swipeUp: function(event, direction, distance, duration, fingerCount) {
        return wheelman.nextZone();
      },
      swipeDown: function(event, direction, distance, duration, fingerCount) {
        return wheelman.previousZone();
      }
    });
  });

  if (window.DEBUG) {
    $("div").click(function() {
      return wheelman.nextZone();
    });
  }

}).call(this);
